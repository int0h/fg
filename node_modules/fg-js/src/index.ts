"use strict";

import * as fs from 'fs';
import * as fse from 'fs-extra';
import * as path from 'path';
import * as gapServer from './gapServer';
import * as browserify from 'browserify';
const tsify = require('tsify');
const microJade = require('micro-jade');
//import * as ts from 'typescript';
import {FgMgr, IFgDeclaration} from './fgMgr';
import * as serverUtils from './serverUtils';
import {Template, TplData} from './tplMgr';

export {Component, getDefaultClass} from './client/componentBase';
export {IGapData} from './client/gapClassMgr';

const fgLibPath = path.resolve(path.dirname(require.resolve('fg-js')) + '/', '..');

function parseTpl(code: string): TplData{
	const mjAst = microJade.parse(code);
	return Template.read(mjAst, null, []);
};

function transformTpl(code: string): string{
	const parsed = parseTpl(code);
	const json = JSON.stringify(parsed, null, 4);
	let res = "const tpl: any = " + json + ";\n";
	res += "export default tpl;";
	return res;
};

interface FgMeta{
	name: string;
	parents: string[];
	path: string;
	tpl: string;
	classFn: string;
	subs: FgMeta[];
}

function toPosixPath(path: string): string {
	return path.replace(/\\/g, '/');
};

function transformFgDir(name: string, parents: string[], srcPath: string, destPath: string){
	let meta: FgMeta = {
		name,
		parents: parents || [],
		path: srcPath,
		tpl: null,
		classFn: null,
		subs: []
	};
	const tplPath = path.resolve(srcPath, './tpl.jade');
	if (serverUtils.fileExist(tplPath)){
		meta.tpl = fs.readFileSync(tplPath).toString();
		const tplDataCode = transformTpl(meta.tpl);
		const tplDestPath = path.resolve(destPath, './tpl.ts');
		fs.writeFileSync(tplDestPath, tplDataCode);
	}else{
		meta.tpl = null;
	};	
	const subDirs = serverUtils.getSubFolders(srcPath);
	subDirs.forEach(dir => {
		const srcDirPath = path.resolve(srcPath, dir);
		const destDirPath = path.resolve(destPath, dir);
		fse.ensureDirSync(destDirPath);
		const childParents = parents.concat([name]); 
		meta.subs.push(transformFgDir(dir, childParents, srcDirPath, destDirPath));
	});
	return meta;
};

function genIncludeFile(meta: FgMeta, fgRoot: string, dest: string): string {
	let codeParts: string[] = [];
	let curId = 0;

	function writeFg(meta: FgMeta){
		if (meta.tpl){
			const fullTplPath = path.resolve(meta.path, './tpl/');
			const relTplPath = path.relative(fgRoot, fullTplPath);
			const importPath = './' + toPosixPath(relTplPath);
			codeParts.push(`import tpl_${curId} from '${importPath}';`);
		}else{
			codeParts.push(`const tpl_${curId}: any = null;`);
		};
		if (meta.classFn){
			//to do
			codeParts.push(`const class_${curId} = getDefaultClass();`);
		}else{
			codeParts.push(`const class_${curId} = getDefaultClass();`);
		};
		codeParts.push(`class_${curId}.init({
			tpl: tpl_${curId},
			name: null
		});`);		
		curId++;
		meta.subs.forEach(writeFg);
	};

	//codeParts.push(`import {getDefaultClass} from '../build/';`);
	codeParts.push(`import {getDefaultClass} from 'fg-js/build/client/componentBase';console.log(getDefaultClass())`);
	//codeParts.push(`const getDefaultClass = require('fg-js');`);
	writeFg(meta);	
	return codeParts.join('\n');
};

export function buildTest(cb: Function){
	const testDir = fgLibPath + '/src/tests/';
	build(testDir + '/fg-src/', process.cwd() + '/temp/fg.js', function(err: Error){
			cb(err);
		});
	// buildRuntime(fgLibPath + '/build/tests/build/runtime.js', function(err: Error){
	// 	if (err){
	// 		cb(err);
	// 		return;
	// 	};
	// 	build(testDir + '/fg-src/', fgLibPath + '/build/tests/build/fg.js', function(err: Error){
	// 		cb(err);
	// 	});
	// });
};


export function buildRuntime(destPath: string, cb: Function){
	const brofy = browserify({
		debug: true
	});
	brofy
		.add(fgLibPath + '/src/client/main.ts')
		.plugin(tsify)
		.bundle(function(err: any, code: Buffer){
			if (err){
				console.error(err);
				return;
			};
			fs.writeFileSync(destPath, code);
			cb(null);
		});
};

const buildCfg = {
    "compilerOptions": {
        "target": "es5",
        "moduleResolution": "node",
        "typeRoots": [
            "../node_modules/@types"
        ],
        "outDir": "./build",
        "inlineSourceMap": true
    },
    "files": [
        "./ts/include.ts"
    ]    
};

export function build(srcPath: string, destPath: string, cb: Function){
	const fgMgr = new FgMgr();
	console.log('sadsad');
	//var tempPath = path.resolve(fgLibPath, './temp');	
	const tempPath = path.resolve(process.cwd(), './temp');
	const meta = transformFgDir(null, [], srcPath, tempPath + '/ts');
	const includeCode = genIncludeFile(meta, srcPath, tempPath + '/ts');
	fs.writeFileSync(path.resolve(process.cwd(), './temp/ts/include.ts'), includeCode);
	const buildCfgJson = JSON.stringify(buildCfg);
	fs.writeFileSync(tempPath + '/tsconfig.json', buildCfgJson);	
	const brofy = browserify({
		debug: true
	});
	brofy
		.add(tempPath + '/ts/include.ts')
		.external([
			"fg-js/build/client/componentBase"
		])
		.plugin(tsify, {
			project: tempPath + '/tsconfig.json'
		})
		.bundle(function(err: any, code: Buffer){
			if (err){
				console.error(err);
				return;
			};
			fs.writeFileSync(destPath, code);
			cb(null);
		});
	//console.log(meta);
};