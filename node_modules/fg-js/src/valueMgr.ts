"use strict";

import * as utils from './utils';
import {IGapData, IScopeTable, Gap} from './client/gapClassMgr';

export type IValuePathItem = string;

export type IPath = IValuePathItem[];

export interface IDataQueryObj {
	dataId?: number;
    path?: IPath;
	source?: string;
	raw?: boolean;
};

export type IDataPath = string[]; 

export interface IScopeData {
	name: string;
	value: IDataQueryObj;
};

export interface IScope {
	name: string;
	value: DataQuery;
};

interface IScopeSet{
	[key: string]: IPath;
};

export type DynamicPath = number[];  

export interface IRenderMeta {
	dynamicPath: DynamicPath;
};

export class DataQuery {
	path: IPath;
	source: string;
	raw: boolean;	
	dataId: number;

	/**
	 * Reads path and returns parsed path.
	 * @param {string[]} parts - array of path's parts.
	 * @param {Object} extraInfo - data object to be added to result.
	 * @returns {Object} path object.
	 */
	constructor (metaObj: IDataQueryObj){
		this.path = metaObj.path;
		this.dataId = metaObj.dataId;
		this.source = metaObj.source || "data";
		this.raw = !!metaObj.raw || false;		
		//const first = parts[0];
		let scopeName: string = null;			
	};

	/**
	 * Parses dot path and returns parsed path.
	 * @param {string} str - text of the path separated by dots.
	 * @param {Object} extraInfo - data object to be added to result.
	 * @returns {Object} path object.
	 */
	static parse(str: string, metaObj?: IDataQueryObj): DataQuery {
		metaObj = metaObj || {};
		metaObj.path = str.trim().split('.');	
		return new DataQuery(metaObj);
	};

	getData(): IDataQueryObj {
		return {
			path: this.path,
			raw: this.raw,
			source: this.source,
			dataId: this.dataId
		};
	};

	toJSON(): IDataQueryObj {
		let data = this.getData();
		if (!data.raw){
			delete data.raw;
		};
		if (data.source === "data"){
			delete data.source;
		};
		return data; 
	};

	clone(): DataQuery{
		return new DataQuery(this.getData());
	};

	resolve(parents: IGapData[]): DataQuery {
		let res = this.clone();		
		res.path = resolveDataPath(this.path, parents);
		return res;
	};

	/**
	 * Returns the value by given path.
	 * @param {Object} meta - gap meta connected to the path.
	 * @param {Object} data - data object rendering in fg.
	 * @param {Object} valuePath - value path to be fetched.
	 * @returns {any} fetched data.
	 */
	getValue(data: any, meta: IRenderMeta): any {
		const sourceTable: any = {
			"data": data
		};
		if (this.dataId !== null){
			return data[this.dataId];
		}
		const sourceData: any = sourceTable[this.source];
		const realPath = calcDataPath(this.path, meta.dynamicPath);
		const res = utils.objPath(realPath, sourceData);
		return res;
	};

	/**
	 * Returns the queried value as string.
	 * @param {Object} meta - gap meta connected to the path.
	 * @param {Object} data - data object rendering in fg.
	 * @param {Object} resolvedPath - resolved path.
	 * @returns {string} rendered string.
	 */
	render(data: Object, meta: IRenderMeta): string{
		const value = this.getValue(data, meta);
		if (value === undefined){
			throw new Error("Cannot render: [" + this.path.join('.') + "] is undefined!");
		};
		let text = value.toString(); 
		if (!this.raw){
			text = utils.escapeHtml(text);		
		};
		return text;
	};

};

export function calcDataPath(path: IDataPath, dynamicPath: DynamicPath): IDataPath {
	let current = 0;
	return path.map(part => (part === "*") 
		? dynamicPath[current++].toString(10)
		: part
	);
};

function relativePath(fromPath: IPath, path: IPath): IPath{
	var resPath = fromPath.slice();
	path.forEach(function(part){
		if (part === "^"){
			resPath.pop();
			return; 
		};
		resPath.push(part);
	});
	return resPath;
};

function getScopeTable(parents: IGapData[]): IScopeTable{
	let res: IScopeTable = {};
	parents.forEach(function(parent: IGapData){
		if (parent.scope){
			res[parent.scope.name] = parent.scope.value.path;
		};
	});
	return res;
};

/**
 * Resolves the path removing all operators from path (e.g. $up).
 * @param {Object} meta - gap meta connected to the path.
 * @param {Object} path - value path object.
 * @returns {Object} resolved path object.
 */
export function resolveDataPath(path: IPath, parents: IGapData[]): IPath{
	const firstPart = path[0];
	if (firstPart && firstPart[0] === "$"){
		const scopeName = firstPart.slice(1); 
		const scopeTable = getScopeTable(parents);		
		const scopePath = scopeTable[scopeName];
		if (!scopePath){
			throw new Error("Scope [" + scopeName + "] not found!");
		};
		const scopeItemPath = scopePath.concat(['*']);
		return relativePath(scopeItemPath, path.slice(1));
	};
	return path;
};