"use strict";

import * as gapServer from './gapServer';
import {Gap, IGapData} from './client/gapClassMgr';
import * as utils from './utils';
import {Component} from './client/componentBase';
import {IAstNode} from './outerTypes';
import gaps from './gaps';
import {IRenderMeta} from './valueMgr';

export interface IWrapper {
	0: string;
	1: string;
};

export interface ITplLangEngine {
	parse: (code: string) => IAstNode;
	render: (ast: IAstNode, data?: any) => string;
	renderWrapper: (ast: IAstNode, data?: any) => string;
}; 

function tplLangPlaceHolder(...args: any[]): any{
	throw new Error('[tplLangEngine] must be overriden');	
};

export type TplData = (string | IGapData)[];

export class Template {
	parts: (string | Gap)[] = [];

	constructor(tplData: TplData, parent: Gap){
		this.parts = tplData.map((part) => {
			if (typeof part === "string"){
				return part;
			};
			const gapClassName = (part as IGapData).type;
			const GapClass = gaps[gapClassName];
			const gap = new GapClass(part as IGapData, parent);	 
			return gap;
		});
	};

	static tplEngine: ITplLangEngine = {
		parse: tplLangPlaceHolder,
		render: tplLangPlaceHolder,
		renderWrapper: tplLangPlaceHolder
	};

	static parse(code: string): TplData {
		const ast = Template.tplEngine.parse(code);
		return Template.read(ast, code, []);
	};

	static read(ast: IAstNode, code: string, parents: IGapData[]): TplData{	

		function iterate(children: IAstNode[]): TplData{
			let parts: TplData = [];
			children.forEach(function(node, id){
				const tagMeta = gapServer.parse(node, parents, code);
				if (tagMeta){				
					parts.push(tagMeta);				
					return; 
				};	
				if (!node.children || node.children.length == 0){
					parts.push(Template.tplEngine.render(node, {}));				
					return;
				};
				const wrap = Template.tplEngine.renderWrapper(node);
				parts.push(wrap[0]);
				parts = parts.concat(iterate(node.children));		
				if (wrap[1]){
					parts.push(wrap[1]);
				}
			});
			return parts;
		};

		return iterate(ast.children);
	};

	render(context: Component, data: any, meta: IRenderMeta){
		let parts: string[] = this.parts.map((part) => {
			if (typeof part === "string"){
				return part;
			};			
			return (part as Gap).render(context, data, meta);
		});
		const code = parts.join('');
		return code;
	};
};
