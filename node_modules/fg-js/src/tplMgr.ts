"use strict";

import * as gapServer from './gapServer';
import {Gap, IGapData} from './client/gapClassMgr';
import * as utils from './utils';
import {Component} from './client/componentBase';
import {IAstNode} from './outerTypes';
import gaps from './gaps';
import {IRenderMeta, IDataPath} from './valueMgr';
import DataDispatcher from './dataDispatcher';

export interface IWrapper {
	0: string;
	1: string;
};

export interface ITplLangEngine {
	parse: (code: string) => IAstNode;
	render: (ast: IAstNode, data?: any) => string;
	renderWrapper: (ast: IAstNode, data?: any) => string;
}; 

function tplLangPlaceHolder(...args: any[]): any{
	throw new Error('[tplLangEngine] must be overriden');	
};

export type TplData = (string | IGapData)[];

export class Template {
	parts: (string | Gap)[] = [];

	constructor(tplData: TplData, parent: Gap){
		this.parts = tplData.map((part) => {
			if (typeof part === "string"){
				return part;
			};
			const gapClassName = (part as IGapData).type;
			const GapClass = gaps[gapClassName];
			const gap = new GapClass(part as IGapData, parent);	 
			return gap;
		});
	};

	static tplEngine: ITplLangEngine = {
		parse: tplLangPlaceHolder,
		render: tplLangPlaceHolder,
		renderWrapper: tplLangPlaceHolder
	};

	static parse(code: string, dataDispatcher: DataDispatcher): TplData {
		const ast = Template.tplEngine.parse(code);
		return Template.read(ast, dataDispatcher, code, []);
	};

	static read(ast: IAstNode, dataDispatcher: DataDispatcher, code: string, parents: IGapData[]): TplData{	

		function iterate(children: IAstNode[]): TplData{
			let parts: TplData = [];
			let curId = 0;
			children.forEach(function(node, id){
				const tagMeta = gapServer.parse(node, dataDispatcher, parents, code);
				if (tagMeta){				
					parts.push(tagMeta);
					tagMeta.tplId = curId;		
					curId++;	
					return; 
				};	
				if (!node.children || node.children.length == 0){
					const code = Template.tplEngine.render(node, {});
					if (code !== ''){
						parts.push(code);
					};				
					return;
				};
				const wrap = Template.tplEngine.renderWrapper(node);
				parts.push(wrap[0]);
				parts = parts.concat(iterate(node.children));		
				if (wrap[1]){
					parts.push(wrap[1]);
				}
			});
			return parts;
		};

		return iterate(ast.children);
	};	

	render(context: Component, data: any, meta: IRenderMeta): string {
		let parts: string[] = this.parts.map((part) => {
			if (typeof part === "string"){
				return part;
			};			
			return (part as Gap).render(context, data[part.tplId], meta);
		});
		const code = parts.join('');
		return code;
	};

	update(context: Component, meta: IRenderMeta, oldData: any, newData: any): void {
		const hash = context.objectStorage.hash.bind(context.objectStorage);
		if (hash(oldData) === hash(newData)){
			return;
		};
		let parts: string[] = this.parts.map((part) => {
			if (typeof part === "string"){
				return part;
			};
			const oldPartData = oldData.content[part.tplId];
			const newPartData = newData.content[part.tplId];
			part.update(context, meta, oldPartData, newPartData);
			// update here
		});
	};

};
