"use strict";

export interface IExtra {
	raw?: boolean;
}

export interface ValueParseFn{
	(str: string, extra: IExtra): any;
};

export interface ValueRenderFn{
	(parsed: any): string;
};

export type ValueParsedType = any;

export type StrTplValue = string | ValueParsedType;

export type StrTplData = StrTplValue[];

export interface IStrTplData {
	parts: StrTplValue[];
	isString?: boolean;	
};

let gapRe = /[\$\#\!]{1}\{[^\}]*\}/gm;

export class StrTpl {
	parts: StrTplValue[];
	isString: boolean;

	constructor (data: IStrTplData, gapMapFn?: Function){
		let parts = data.parts;
		if (gapMapFn){
			parts = parts.map(part => {
				if (typeof part === "string"){
					return part;
				};
				return gapMapFn(part);
			});
		};
		this.parts = parts;
		this.isString = data.isString || false;
	};

	static parse(tpl: string, valueParseFn: ValueParseFn): IStrTplData{
		const gapStrArr = tpl.match(gapRe);
		if (!gapStrArr){			
			return {
				parts: [tpl],
				isString: true
			};
		};	
		const gaps = gapStrArr.map(function(part){
			const partValue: string = part.slice(2, -1);
			const partRes: any = valueParseFn(partValue, {
				raw: part[0] === "!"
			});			
			return partRes;
		});		
		const strings = tpl.split(gapRe);
		return {
			parts: mixArrays(strings, gaps)			
		};
	};

	render(valueRenderFn: ValueRenderFn): string{
		if (this.isString){
			return this.parts[0];
		};
		const renderedParts = this.parts.map(part => {
			if (typeof part === "string"){
				return part;
			};
			return valueRenderFn(part);
		});
		return renderedParts.join('');	
	};

};

function mixArrays(...arrs: any[][]): any[]{
	let maxLength = 0;
	let totalLength = 0;
	for (let i = 0; i < arrs.length; i++){
		maxLength = Math.max(arrs[i].length, maxLength);
		totalLength += arrs[i].length;
	};
	let resArr: any[] = [];
	const arrayCount = arguments.length;
	for (let id = 0; id < maxLength; id++){				
		for (let j = 0; j < arrayCount; j++){
			if (arguments[j].length > id){
				resArr.push(arguments[j][id]);
			};
		};
	};
	return resArr;
};