"use strict";

import * as utils from '../utils';  
import * as valueMgr from '../valueMgr';  
import {Gap, IGapData} from '../client/gapClassMgr';  
import {Component} from '../client/componentBase';
import {IAstNode} from '../outerTypes'; 
import {Template, TplData} from '../tplMgr';
import * as anchorMgr from '../anchorMgr';
import {default as GScopeItem, IScopeItemParsedData} from './scope-item';
import {IDataPath, IDataQueryObj, IScope, IScopeData, DataQuery, IRenderMeta} from '../valueMgr';

function renderScopeContent(context: Component, scopeMeta: GScope, scopeData: any, data: any, idOffset: number, meta: IRenderMeta){
	const isArray = Array.isArray(scopeData);
	if (!isArray){
		scopeData = [scopeData];
	};
	const parts = scopeData.map(function(dataItem: any, id: number){
		let dataSource = scopeMeta.scope.value;
		if (isArray){
			//dataSource.path.push('*');
		};
		let itemCfg: IScopeItemParsedData = {
			"type": "scopeItem",
			"dataSource": dataSource,
			"content": null
		};
		if (scopeMeta.eid){
			itemCfg.eid = scopeMeta.eid + '-item';
		};
		const itemGap = new GScopeItem(itemCfg, scopeMeta);
		const itemMeta: IRenderMeta = {
			dynamicPath: meta.dynamicPath.concat([id])
		};	
		return itemGap.render(context, data, itemMeta);
	});
	return parts;
};

export interface IScopeParsedData extends IGapData {
	scope: IScopeData;
	content: TplData;
};

export default class GScope extends Gap{
	content: Template;
	scope: IScope;
	items: Gap[];
	type: string = "scope";
	
	public static isVirtual = true;

	constructor (parsedMeta: IScopeParsedData, parent: Gap){
		super(parsedMeta, parent);	
		this.scope.value = new DataQuery(parsedMeta.scope.value);	
		this.content = new Template(parsedMeta.content, parent);
		this.paths = [this.scope.value.path];
	};

	static parse(node: IAstNode, parents: IGapData[], html?: string): IGapData{
		if (node.tagName !== "scope"){
			return null;
		};
		const scopeName: string = "scope";
		const dataSource = utils.parsePath(node).resolve(parents);		
		const meta: IScopeParsedData = {
			type: "scope",
			eid: node.attrs.id || null,
			scope: {
				name: scopeName,
				value: dataSource,
			},
			content: null
		};
		meta.content = Template.read(node, null, parents.concat([meta]));
		return meta;
	};

	render(context: Component, data: any, meta: IRenderMeta): string{
		this.items = [];
		const scopeData = this.scope.value.getValue(data, meta);	
		const anchorCode = anchorMgr.genCode(context, this);		
		const parts = renderScopeContent(context, this, scopeData, data, 0, meta);	
		return parts.join('\n') + anchorCode;
	};

	update(context: Component, meta: GScope, scopePath: any, value: any, oldValue: any){
		value = value || [];
		oldValue = oldValue || [];
		for (let i = value.length; i < oldValue.length; i++){
		};
		if (value.length > oldValue.length){
			const dataSlice = value.slice(oldValue.length);
			// const newContent = renderScopeContent(context, meta, dataSlice, context.data, oldValue.length).join('\n');
			// const anchor = anchorMgr.find(context, meta);		
			// anchorMgr.insertHTML(anchor, 'before', newContent);
		};
	};

};