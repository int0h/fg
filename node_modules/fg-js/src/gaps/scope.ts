"use strict";

import * as utils from '../utils/utils';  
import * as valueMgr from '../common/valueMgr';  
import {Gap, IGapData} from '../client/gapClassMgr';  
import {Component} from '../client/componentBase';
import {IAstNode} from '../outerTypes'; 
import {Template, TplData} from '../common/tplMgr';
import * as anchorMgr from '../client/anchorMgr';
import {IDataPath, IDataQueryObj, IScope, IScopeData, DataQuery, IRenderMeta} from '../common/valueMgr';
import DataDispatcher from '../dataDispatcher';

export interface IScopeParsedData extends IGapData {
	scope: IScopeData;
	content: TplData;
};

export default class GScope extends Gap{
	content: Template;
	scope: IScope;
	items: Gap[];
	type: string = "scope";
	
	public static isVirtual = true;

	constructor (parsedMeta: IScopeParsedData, parent: Gap){
		super(parsedMeta, parent);	
		this.scope.value = this.dataSource;	
		this.content = new Template(parsedMeta.content, this);
	};

	static parse(node: IAstNode, dataDispatcher: DataDispatcher, parents: IGapData[], html?: string): IGapData {
		if (node.tagName !== "scope"){
			return null;
		};
		const scopeName: string = "scope";
		const dataSource = utils.parsePath(node);	
		const scopeDD = dataDispatcher.reg([dataSource], true, scopeName);	
		const meta: IScopeParsedData = {
			line: node.line,
			dataSource,
			type: "scope",
			eid: node.attrs.id || null,
			scope: {
				name: scopeName,
				value: dataSource.toJSON(),
			},
			content: null
		};
		meta.content = Template.read(node, scopeDD, null, parents.concat([meta]));
		return meta;
	};

	renderParts(context: Component, items: any[], meta: IRenderMeta): string {
		const parts: string[] = items.map((dataPart: any, id: number) => {			
			const partMeta: IRenderMeta = {
				dynamicPath: meta.dynamicPath.concat([id])
			};
			return this.content.render(context, dataPart, partMeta);
		});
		return parts.join('\n');
	};

	render(context: Component, data: any, meta: IRenderMeta): string {
		const partsCode = this.renderParts(context, data.items, meta);
		const upAnchorCode = anchorMgr.genCode(context, this, 'up');		
		const downAnchorCode = anchorMgr.genCode(context, this, 'down');
		return [upAnchorCode, partsCode, downAnchorCode].join('\n');
	};

	update(context: Component, meta: IRenderMeta, oldData: any, newData: any){
		const hash = context.objectStorage.hash.bind(context.objectStorage);
		if (hash(oldData) === hash(newData)){
			return;
		};
		let start = 0;
		let end = newData.items.length;
		const oldLen = oldData.items.length;
		const newLen = newData.items.length;
		if (newLen !== oldLen){
			if (newLen > oldLen){
				end = oldLen;
				const newContent = this.renderParts(context, newData.items.slice(end), meta);
				const anchor = anchorMgr.find(context, this, 'down');
				anchorMgr.insertHTML(anchor, 'before', newContent);				
			} else {
				if (newData.items[newLen - 1] === oldData.items[oldLen - 1]){
					const firstSaved = 1;
				} else {

				}
			};		
		};
		for (let i = start; i < end; i++){
			const newItem = newData.items[i];
			const oldItem = oldData.items[i];
			if (hash(oldItem) === hash(newItem)){
				continue;
			};
			const rm: IRenderMeta = {
				dynamicPath: meta.dynamicPath.concat([i])
			}
			this.content.update(context, rm, oldItem, newItem);
		};
		
	};

};