"use strict";

import * as utils from '../utils';  
import {IAttrs} from '../utils/tplUtils';  
import {IStrTplData, StrTpl} from '../strTpl';  
import {Gap, IGapData} from '../client/gapClassMgr';  
import {Component} from '../client/componentBase'; 
import {IAstNode} from '../outerTypes';
import {Template, TplData} from '../tplMgr';
import {IDataPath, IDataQueryObj, DataQuery, IRenderMeta} from '../valueMgr';
import DataDispatcher from '../dataDispatcher';

function isScope(item: Gap){
	if (typeof item === "string"){
		return false;
	};
	return item.type === "scope";
};

export interface IRawParsedData extends IGapData {
	value: IDataQueryObj;
	tagName: string;
	attrs: RawAttrs;
	content: TplData;
};

export interface IRawAttr {
	name: IStrTplData;
	value: IStrTplData;
};

export interface IAttr {
	name: StrTpl;
	value: StrTpl;
};

export type RawAttrs = IRawAttr[];

export default class GRaw extends Gap{
	type: string;
	value: DataQuery;
	tagName: string;
	attrs: IAttr[];
	content: Template;
	
	public static priority: number = -1;
	public static isVirtual = false; 

	dataSourceInit(parsed: IRawParsedData){
		if (this.value){
			this.value = new DataQuery(parsed.value);			
		};
		const attrMapFn = (val: IStrTplData) => {
			return new StrTpl(val, (gap: IDataQueryObj) => {				
				return new DataQuery(gap);
			});
		};
		this.attrs = parsed.attrs.map(attr => {
			return {
				name: attrMapFn(attr.name),			
				value: attrMapFn(attr.value)			
			};		
		});
	};

	constructor (parsedMeta: IRawParsedData, parent: Gap){
		super(parsedMeta, parent);
		this.type = "raw";
		this.content = new Template(parsedMeta.content, this);				
	};

	static parse(node: IAstNode, dataDispatcher: DataDispatcher, parents: IGapData[], html?: string): IRawParsedData{
		if (node.type !== "tag"){
			return null;
		};
		const dd = dataDispatcher.reg([]);
		let isRootNode = false;
		let isScopeItem = false;
		let isScopeHolder = false;
		let hasDynamicAttrs = false;
		const meta: IRawParsedData = {
			line: node.line,
			dataSource: null,
			type: "raw",
			tagName: node.tagName,
			attrs: [],
			value: null,
			eid: null,
			content: []
		};
		isRootNode = node.parent.type !== "tag";
		if ("id" in node.attrs){
			meta.eid = node.attrs.id.value;
			delete node.attrs.id;
		};
		let attrsArr = utils.objToKeyValue(node.attrs, 'name', 'value');
		attrsArr = attrsArr.map(function(attr){	
			const attrVal = attr.value.type === "string"
				? attr.value.value
				: (attr.value.escaped ? '#' : '!') + '{' + attr.value.key + '}';
			const parseFn = (ref: any, extra: any) => {
				let ds = DataQuery.parse(ref, extra)
				dd.add(ds);
				return ds.toJSON();
			};		
			const value = StrTpl.parse(attrVal, parseFn);
			const name = StrTpl.parse(attr.name, parseFn);
			if (!value.isString || !name.isString){
				hasDynamicAttrs = true;
			};
			return {name, value};
		});
		meta.attrs = attrsArr;
		if (node.value){
			let ds = DataQuery.parse(node.value.path, {
				raw: !node.value.escaped
			});
			dd.add(ds);
			meta.value = ds.toJSON();
		};				
		meta.content = Template.read(node, dd, null, parents.concat([meta]));		
		if (meta.content.some(isScope)){
			isScopeHolder = true;			
		};
		const parentMeta = parents[parents.length - 1];
		if (parentMeta && parentMeta.type === "scope"){
			isScopeItem = true;
		};
		if (
				!hasDynamicAttrs 
				&& !meta.eid
				&& !isRootNode 
				&& !isScopeHolder 
				&& !isScopeItem
				&& !meta.value
			){
			return null;
		};
		return meta;
	};	

	render(context: Component, data: any, meta: IRenderMeta): string{
		let attrObj: any = {};
		this.attrs.forEach((attr) => {
			const renderFn = (ref: DataQuery) => ref.render(data.self, meta); 
			const name = attr.name.render(renderFn);
			const value = attr.value.render(renderFn);
			attrObj[name] = value;
		});
		attrObj.id = this.genId(context.id, meta);
		let triggers: string[][] = [];
		const inner = this.value 
			? this.value.render(data.self, meta)
			: this.content.render(context, data.content, meta);
		return utils.renderTag({
			"name": this.tagName,
			"attrs": attrObj,
			"innerHTML": inner
		});
	};

	update(context: Component, meta: IRenderMeta, oldData: any, newData: any){
		let attrObj: any = {};
		const dom = this.getDom(context.id, meta)[0];
		this.attrs.forEach((attr) => {
			const renderFn = (ref: DataQuery) => ref.render(newData, meta); 
			const name = attr.name.render(renderFn);
			const value = attr.value.render(renderFn);
			attrObj[name] = value;
		});
		// update attrs
		if (this.value){
			const val = this.value.update(oldData.self, newData.self, meta);
			if (val !== null){
				dom.innerHTML = val;
			};
		};
		this.content.update(context, meta, oldData, newData);
	
	};

};