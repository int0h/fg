"use strict";

import * as utils from '../utils';  
import {IAttrs} from '../utils/tplUtils';  
import {IStrTplData, StrTpl} from '../strTpl';  
import {Gap, IGapData} from '../client/gapClassMgr';  
import {Component} from '../client/componentBase'; 
import {IAstNode} from '../outerTypes';
import {Template, TplData} from '../tplMgr';
import {IDataPath, IDataQueryObj, DataQuery, IRenderMeta} from '../valueMgr';

function isScope(item: Gap){
	if (typeof item === "string"){
		return false;
	};
	return item.type === "scope";
};

export interface IRawParsedData extends IGapData {
	value: IDataQueryObj;
	tagName: string;
	attrs: RawAttrs;
	content: TplData;
};

export interface IRawAttr {
	name: IStrTplData;
	value: IStrTplData;
};

export interface IAttr {
	name: StrTpl;
	value: StrTpl;
};

export type RawAttrs = IRawAttr[];

export default class GRaw extends Gap{
	type: string;
	value: DataQuery;
	tagName: string;
	attrs: IAttr[];
	content: Template;
	
	public static priority: number = -1;
	public static isVirtual = false; 

	constructor (parsedMeta: IRawParsedData, parent: Gap){
		super(parsedMeta, parent);
		this.type = "raw";
		this.content = new Template(parsedMeta.content, parent);		
		this.paths = [];
		if (this.value){
			this.value = new DataQuery(parsedMeta.value);
			this.paths.push(this.value.path);
		};
		const attrMapFn = (val: IStrTplData) => {
			return new StrTpl(val, (gap: IDataQueryObj) => {
				this.paths.push(gap.path);
				return new DataQuery(gap);
			});
		};
		this.attrs = this.attrs.map(attr => {
			return {
				name: attrMapFn(attr.name),			
				value: attrMapFn(attr.value)			
			};		
		});
	};

	static parse(node: IAstNode, parents: IGapData[], html?: string): IRawParsedData{
		if (node.type !== "tag"){
			return null;
		};
		let isRootNode = false;
		let isScopeItem = false;
		let isScopeHolder = false;
		let hasDynamicAttrs = false;
		const meta: IRawParsedData = {
			type: "raw",
			tagName: node.tagName,
			attrs: [],
			value: null,
			eid: null,
			content: []
		};
		isRootNode = node.parent.type !== "tag";
		if ("id" in node.attrs){
			meta.eid = node.attrs.id.value;
			delete node.attrs.id;
		};
		let attrsArr = utils.objToKeyValue(node.attrs, 'name', 'value');
		attrsArr = attrsArr.map(function(attr){	
			const attrVal = attr.value.type === "string"
				? attr.value.value
				: (attr.value.escaped ? '#' : '!') + '{' + attr.value.key + '}';
			const parseFn = (ref, extra) => DataQuery.parse(ref, extra).resolve(parents);		
			const value = StrTpl.parse(attrVal, parseFn);
			const name = StrTpl.parse(attr.name, parseFn);
			if (!value.isString || !name.isString){
				hasDynamicAttrs = true;
			};
			return {name, value};
		});
		meta.attrs = attrsArr;
		if (node.value){
			meta.value = DataQuery.parse(node.value.path, {
				raw: !node.value.escaped
			});
		};				
		meta.content = Template.read(node, null, parents.concat([meta]));		
		if (meta.content.some(isScope)){
			isScopeHolder = true;			
		};
		const parentMeta = parents[parents.length - 1];
		if (parentMeta && parentMeta.type === "scope"){
			isScopeItem = true;
		};
		if (
				!hasDynamicAttrs 
				&& !meta.eid
				&& !isRootNode 
				&& !isScopeHolder 
				&& !isScopeItem
				&& !meta.value
			){
			return null;
		};
		return meta;
	};	

	render(context: Component, data: any, meta: IRenderMeta): string{
		const attrsArr = this.attrs;
		let attrObj: any = {};
		attrsArr.forEach((attr) => {
			const renderFn = (ref: DataQuery) => ref.render(data, meta); 
			const name = attr.name.render(renderFn);
			const value = attr.value.render(renderFn);
			attrObj[name] = value;
		});
		let triggers: string[][] = [];
		const inner = this.value 
			? this.value.render(data, meta)
			: this.content.render(context, data, meta);
		return utils.renderTag({
			"name": this.tagName,
			"attrs": attrObj,
			"innerHTML": inner
		});
	};

	update(context: Component, meta: Gap, scopePath: any, value: any){
		// to do value update
		/*var attrData = utils.objPath(meta.scopePath, context.data);
		var renderedAttrs = utils.renderAttrs(meta.attrs, attrData);*/
	// 	const asRaw = meta as GRaw;
	// 	const attrsArr = utils.objToKeyValue(asRaw.attrs, 'name', 'value');
	// 	let attrObj: any = {};
	// 	attrsArr.forEach(function(attr){
	// 		const renderFn = (ref: DataQuery) => ref.render(context.data, meta); 
	// 		const name = strTpl.render(attr.name, valueMgr.render.bind(null, meta, context.data));
	// 		const value = strTpl.render(attr.value, function(path){
	// 			return valueMgr.render(meta, context.data, asRaw.value);
	// 		});
	// 		attrObj[name] = value;
	// 	});
	// 	const dom = meta.getDom()[0];
	// 	if (asRaw.value && asRaw.value.path.join('-') === scopePath.join('-')){
	// 		dom.innerHTML = asRaw.value.escaped 
	// 			? utils.escapeHtml(value)
	// 			: value;
	// 	};
	// 	utils.objFor(attrObj, function(value: string, name: string){
	// 		const oldVal = dom.getAttribute(name);
	// 		if (oldVal !== value){
	// 			dom.setAttribute(name, value);
	// 		};
	// 	});		
	};

};