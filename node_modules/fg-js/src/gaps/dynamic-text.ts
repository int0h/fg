"use strict";

import * as utils from '../utils/utils';  
import {DataQuery, IRenderMeta} from '../common/valueMgr';  
import {IStrTplData, StrTpl} from '../utils/strTpl';  
import {Gap, IGapData} from '../client/gapClassMgr';  
import {Component} from '../client/componentBase';
import {IAstNode} from '../outerTypes';
import GData from './data';
import DataDispatcher from '../dataDispatcher';

export interface IDynamicTextParsedData extends IGapData {
	tpl: IStrTplData;
};

export default class GDynamicText extends Gap{

	tpl: StrTpl;
	type: string = "dynamicText";

	constructor (parsedMeta: IDynamicTextParsedData, parent: Gap){
		super(parsedMeta, parent);
		this.tpl = new StrTpl(parsedMeta.tpl);
	};

	static parse(node: IAstNode, dataDispatcher: DataDispatcher, parents: IGapData[]): IGapData{
		if (node.type !== "text"){
			return null;
		};
		const dss: DataQuery[] = [];
		const tpl = StrTpl.parse(node.text, (ref, extra) => {
			let ds = DataQuery.parse(ref, extra);
			dss.push(ds);
			return ds;
		});
		if (tpl.isString){
			return null;
		};
		const dd = dataDispatcher.reg(dss);
		const meta: IDynamicTextParsedData = {			
			line: node.line,
			dataSource: null,
			type: "dynamicText",
			tpl: tpl
		};
		return meta;
	};

	render(context: Component, data: any, meta: IRenderMeta){
		return this.tpl.render((dataSource: DataQuery) => {			
			const dataMeta = {
				line: this.line,
				"type": "data",
				dataSource			
			};
			const itemMeta: GData = new GData(dataMeta, this);
			return itemMeta.render(context, data, meta);
		});
	};

};