"use strict";

import * as fs from 'fs-extra';
import * as path from 'path';
import * as browserify from 'browserify';
const tsify = require('tsify');
const microJade = require('micro-jade');
import * as serverUtils from './serverUtils';
import {Template, TplData} from './tplMgr';

Template.tplEngine = microJade;

const fgLibPath = path.resolve(path.dirname(require.resolve('fg-js')) + '/', '..');

function transformTpl(code: string): string{
	const parsed = Template.parse(code);
	const json = JSON.stringify(parsed, null, 4);
	let res = "const tpl: any = " + json + ";\n";
	res += "export default tpl;";
	return res;
};

function toPosixPath(path: string): string {
	return path.replace(/\\/g, '/');
};

function $path(...parts: string[]): string {
	const posixPaths = parts.map(part => toPosixPath(part));
	return toPosixPath(path.join.apply(path.resolve, posixPaths));
};

interface IFgMeta{
	name: string;
    nameSpace: string;
	objPath: string[];
	path: string;
	tpl: string;
	classFn: string;
	subs: IFgMeta[];
};

interface IComponentSet {
    name: string;
    items: IFgMeta[];
};

function transformFgDir(nameSpace: string, srcPath: string, destPath: string): IComponentSet {	
    
    function iterate(name: string, objPath: string[], srcPath: string, destPath: string): IFgMeta {
        let meta: IFgMeta = {
            name,
            nameSpace,
            objPath,
            path: srcPath,
            tpl: null,
            classFn: null,
            subs: []
        };
        const tplPath = $path(srcPath, './tpl.jade');
        if (serverUtils.fileExist(tplPath)){
            meta.tpl = fs.readFileSync(tplPath).toString();
            const tplDataCode = transformTpl(meta.tpl);
            const tplDestPath = $path(destPath, './tpl.ts');
            fs.writeFileSync(tplDestPath, tplDataCode);
        }else{
            meta.tpl = null;
        };
        const subDirs = serverUtils.getSubFolders(srcPath);
        subDirs.forEach(dir => {
            const srcDirPath = $path(srcPath, dir);
            const destDirPath = $path(destPath, dir);
            fs.ensureDirSync(destDirPath);
            const childObjPath = objPath.concat([dir]); 
            meta.subs.push(iterate(dir, childObjPath, srcDirPath, destDirPath));
        });
        return meta;
    };

    let res: IComponentSet = {
        name: nameSpace,
        items: []
    };
    const subDirs = serverUtils.getSubFolders(srcPath);
    res.items = subDirs.map(dir => {
        const srcDirPath = $path(srcPath, dir);
        const destDirPath = $path(destPath, dir);
        fs.ensureDirSync(destDirPath);
        return iterate(dir, [dir], srcDirPath, destDirPath);
    });			
    return res;
};


function genIncludeFile(meta: IComponentSet, fgRoot: string, dest: string): string {
	let codeParts: string[] = [];
	let curId = 0;
    let classTree: any = {};

	function writeFg(meta: IFgMeta, classTreeBranch: any){
        const className = `class_${curId}`;
        const relPath = toPosixPath(path.relative(fgRoot, meta.path));
        codeParts.push(`//component ${relPath}:`);        
		if (meta.tpl){
			const importPath = `./${relPath}/tpl`;
			codeParts.push(`import tpl_${curId} from '${importPath}';`);
		}else{
			codeParts.push(`const tpl_${curId}: any = null;`);
		};
		if (meta.classFn){
			//to do
			codeParts.push(`const ${className} = getDefaultClass();`);
		}else{
			codeParts.push(`const ${className} = getDefaultClass();`);
		};
		codeParts.push(`${className}.init({
			tpl: tpl_${curId},
			name: null
		});`);		
        const objPath = meta.objPath.join('.');        
        classTreeBranch[meta.name] = {};
        let childBranch = classTreeBranch[meta.name]; 
        classTreeBranch[meta.name].$ = `#${className}`;
        codeParts.push('\n\n');
		curId++;
		meta.subs.forEach(sub => writeFg(sub, childBranch));
	};

	//codeParts.push(`import {getDefaultClass} from '../build/';`);
	codeParts.push(`import {getDefaultClass, load} from 'fg-js/build/client/main';`);
    codeParts.push('\n\n');
	//codeParts.push(`const getDefaultClass = require('fg-js');`);
    meta.items.forEach(item => writeFg(item, classTree));
    const classTreeCode = JSON.stringify(classTree, null, 4)
        .replace(/"#(\w+_\d+)"/g, (subStr, name) => name);
	codeParts.push(`\n\nexport const classTree = ${classTreeCode};`);
	codeParts.push(`\n\nload(classTree);`);
	return codeParts.join('\n');
};

export function buildTest(cb: Function){
	const testDir = $path(process.cwd(), './tests');
	buildRuntime(process.cwd() + '/temp/runtime.js', function(err: Error){
		if (err){
			cb(err);
			return;
		};		
		build(
			$path(testDir, '/fg-src/'), 
			$path(process.cwd(), '/temp/fg.js'), 
			function(err: Error){
				cb(err);
			}
		);
	});
};

const buildRuntimeCfg = {
    "compilerOptions": {
        "target": "es5",
        "moduleResolution": "node",
        "typeRoots": [
            $path(fgLibPath, "./node_modules/@types")
        ],
        "outDir": "./build",
        "inlineSourceMap": true
    },
    "files": [
        "./ts/include.ts"
    ]    
};

export function buildRuntime(destPath: string, cb: Function){
	const brofy = browserify({
		debug: true
	});
	brofy
		.add($path(fgLibPath, '/src/client/main.ts'))
		.plugin(tsify, {
			project: buildRuntimeCfg
		})
		.require(fgLibPath + '/src/client/main.ts', { expose: 'fg-js/build/client/main' })
		.bundle(function(err: any, code: Buffer){
			if (err){
				console.error(err);
				return;
			};
			fs.writeFileSync(destPath, code);
			cb(null);
		});
};

const buildCfg = {
    "compilerOptions": {
        "target": "es5",
        "moduleResolution": "node",
        "typeRoots": [
            "../node_modules/@types"
        ],
        "outDir": "./build",
        "inlineSourceMap": true
    },
    "files": [
        "./ts/include.ts"
    ]
};

export function build(srcPath: string, destPath: string, cb: Function){	
	const tempPath = $path(process.cwd(), './temp');
	const meta = transformFgDir(null, srcPath, tempPath + '/ts');
	const includeCode = genIncludeFile(meta, srcPath, tempPath + '/ts');
	fs.writeFileSync($path(process.cwd(), './temp/ts/include.ts'), includeCode);
	const brofy = browserify({
		debug: true
	});
	brofy
		.add(tempPath + '/ts/include.ts')
		.external([
			"fg-js/build/client/main"
		])
		.plugin(tsify, {
			project: buildCfg
		})
		.bundle(function(err: any, code: Buffer){
			if (err){
				console.error(err);
				return;
			};
			fs.writeFileSync(destPath, code);
			cb(null);
		});
};