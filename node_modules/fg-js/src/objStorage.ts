"use strict";

function MapPolyfill(){
	this.keyStore = [];
	this.valueStore = [];
	this.lastKey = {
		keyObj: NaN,
		keyId: NaN 
	};
};

MapPolyfill.prototype.find = function(keyObj){
	if (keyObj === this.lastKey.keyObj){
		return this.lastKey.keyId;
	};
	var found = this.keyStore.indexOf(keyObj);
	this.lastKey = {
		keyObj: keyObj,
		keyId: found
	};
	return found;
};

MapPolyfill.prototype.has = function(keyObj){
	var found = this.find(keyObj);
	return found !== -1;
};

MapPolyfill.prototype.get = function(keyObj){
	var found = this.find(keyObj);
	if (found === -1){
		return undefined;
	};
	return this.valueStore[found];
};

MapPolyfill.prototype.set = function(keyObj, value){
	var found = this.find(keyObj);
	if (found === -1){
		found = this.keyStore.length;
		this.lastKey.keyId = found;
		this.keyStore.push(keyObj);
	};
	this.valueStore[found] = value;	
};


function MapPolyfill2(){
	this.store = {};
};

MapPolyfill2.prototype.find = function(keyObj){
	return JSON.stringify(keyObj);
};

MapPolyfill2.prototype.has = function(keyObj){
	return this.find(keyObj) in this.store;
};

MapPolyfill2.prototype.get = function(keyObj){	
	return this.store[this.find(keyObj)];
};

MapPolyfill2.prototype.set = function(keyObj, value){
	this.store[this.find(keyObj)] = value;
};



function ObjectStorage(){

};

var curId = 0;
var objectStore = [];
for (var i = 0; i < 7; i++){
	objectStore[i] = {};	
};
var objCache = new Map();

function getIdFromStr(kind, objCode){
	var id = objectStore[kind][objCode];
	if (id === undefined){
		id = curId;
		curId++;
		objectStore[kind][objCode] = id;
	};
	return id;
};

var supportedTypes = {
	"number": 0,
	"array": 1,
	"boolean": 2,
	"null": 3,
	"object": 4,
	"string": 5,
	"undefined": 6
};

function throwError(err){
	throw new Error(err);
};

function getHashStr(val){
	if (val === undefined){
		return getIdFromStr(supportedTypes["undefined"], val);
	};
	if (val === null){
		return getIdFromStr(supportedTypes["null"], val);
	};
	var type = typeof val;
	if (!(type in supportedTypes)){
		throwError("Type " + type + " is not supported");
	};
	if (type !== "object"){	
		return getIdFromStr(supportedTypes[type], val.toString());
	};
	if (Array.isArray(val)){
		var content = [];
		var parts = [];
		for (var i = 0; i < val.length; i++){
			var item = val[i];
			var res = hash(item);			
			parts.push(res);
		};		
		return getIdFromStr(supportedTypes.array, parts.join(','));
	};
	var keys = Object.keys(val).sort();
	var parts = [];
	//keys.forEach(function(key){
	for (var i = 0; i < keys.length; i++){
		var key = keys[i];
		var value = val[key];
		var keyHash = getIdFromStr(supportedTypes.string, key);		
		var valHash = hash(value);	
		parts.push(keyHash + '=' + valHash);
	};
	//});
	return getIdFromStr(supportedTypes.object, parts.join(','));
};

function hash(val){
	if (typeof val !== "object"){
		return getHashStr(val);
	};
	var found = objCache.get(val);
	if (found !== undefined){
		return found;
	};	
	var code = getHashStr(val);
	objCache.set(val, code);
	return code;
};

ObjectStorage.prototype.add = function(obj){
    
};

var i=9999; while(i--){hash()};
var i=9999; while(i--){DeepDiff(0,0)};

function getDiff(baseObj, newObj, path){
	path = path || [];
	var baseHash = hash(baseObj);
	var newHash = hash(newObj);
	if (baseHash === newHash){
		return [];
	};
	if (newObj === undefined 
		|| newObj === null
		|| ['number', 'string', 'boolean'].indexOf(typeof newObj) >= 0
		|| typeof baseObj !== typeof newObj
		|| Array.isArray(baseObj) !== Array.isArray(newObj)){
		return [{
			type: "set",
			value: newObj,
			path: path
		}];
	};
	if (typeof newObj !== "object"){	
		throw new Error("Type " + typeof newObj + " is not supported");
	};
	var diff = [];
	if (Array.isArray(newObj)){		
		var lenDiff = newObj.length - baseObj.length;
		if (lenDiff !== 0){
			var bEnd = baseObj[baseObj.length - 1];
			var nEnd = newObj[newObj.length - 1];
			var isBefore = bEnd === nEnd;
			if (lenDiff > 0){
				var items = isBefore
					? newObj.slice(0, lenDiff)
					: newObj.slice(baseObj.length)
				diff.push({
					path: path,
					type: "insert",
					items: items,
					pos: isBefore ? 0 : baseObj.length
				});
			}else{
				var delStart = isBefore
					? 0
					: newObj.length;
				diff.push({
					path: path,
					type: "splice",
					pos: delStart,
					len: -lenDiff
				});
			};	
		};
		var bha = baseObj.map(hash);
		var nha = newObj.map(hash);
		var start = isBefore ? Math.abs(lenDiff) : 0;
		var end = Math.min(bha.length, nha.length);
		for (var i = start; i < end; i++){			
			if (bha[i] === nha[i]){
				continue;
			};
			var itemDiff = getDiff(baseObj[i], newObj[i], path.concat([i]));
			diff = diff.concat(itemDiff);
		};
		return diff;
	};
	for (var key in newObj){
		var bp = baseObj[key];
		var np = newObj[key];
		if (hash(bp) === hash(np)){
			continue;
		};
		var itemDiff = getDiff(bp, np, path.concat([key]));
		diff = diff.concat(itemDiff);
	};
	for (var delKey in baseObj){
		if (delKey in newObj){
			continue;
		};
		diff.push({
			type: "delete",
			path: path.concat([delKey])
		});

	}
	return diff;
};