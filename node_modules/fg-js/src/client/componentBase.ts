"use strict";

import EventEmitter from '../eventEmitter';
import {TransformUtils} from '../dataDispatcher';
import * as globalEvents from './globalEvents';
import {Gap} from './gapClassMgr';
import {IRenderMeta} from '../valueMgr';
import {Template, TplData} from '../tplMgr';
import {default as GRoot, IRootParsedData} from '../gaps/root';
import ObjectStorage from '../objectStorage'

export const fgClassTable: typeof Component[] = [];
export const fgInstanceTable: Component[] = [];
export const fgClassDict: any = {};

export interface IFgClassOpts{
	tpl: TplData;
	name: string;
	dataTransform: Function;
};

export type ComponentClass = new (parent: Component, selfMeta: Gap) => Component;

export abstract class Component{
	static id: number;
    static instances: Component[] = [];
	static tpl: Template;
    static rootGap: GRoot;
	static name: string;
	static eventEmitter: EventEmitter;
	static createFn: Function;   
	static transformData: Function;

    id: number;
	code: string;
	//dom: HTMLElement[];
    Class: typeof Component;
	data: any;
	selfGap: Gap;
	parent: Component;
	eventEmitter: EventEmitter;
	childFgs: Component[];
	objectStorage: ObjectStorage;
	tplData: any; 
	currentHash: number;

    constructor(parent: Component, selfMeta: Gap){  
        this.Class = this.constructor as typeof Component;         
		this.id = fgInstanceTable.length;  
		this.Class.instances.push(this);
		this.code = null;
		this.parent = parent || null;
		this.eventEmitter = new EventEmitter(Component.eventEmitter);
		this.childFgs = [];
		fgInstanceTable.push(this);	
        this.selfGap = selfMeta;
		this.objectStorage = new ObjectStorage();
	};

	static on(name: string, selector: string, fn?: Function){		
		if (arguments.length === 2){
			name = name;
			fn = arguments[1];
			selector = null;
		}else{
			var originalFn = fn;
			fn = function(event: any){			
				if (match(this, event.target, selector)){
					originalFn.call(this, event);
				};
			};
		};
		globalEvents.listen(name);
		this.eventEmitter.on(name, fn);	
	};

	static emit(/*name..., rest*/){
		this.eventEmitter.emit.apply(this.eventEmitter, arguments);	
	};

	static emitApply(name: string, thisArg: any, args: any[]){
		this.eventEmitter.emitApply(name, thisArg, args);	
	};

	static cookData(data: any){
		return data;
	};  

	static init(data: IFgClassOpts){
        this.tpl = new Template(data.tpl || [], null);
		this.transformData = data.dataTransform;
        const rootData: IRootParsedData = {
			line: null,
			dataSource: null,
            type: "root",
            content: data.tpl,
            eid: null
        };
        this.rootGap = data.tpl !== null
			? new GRoot(rootData)
			: null;
        this.id = fgClassTable.length; 
        fgClassTable.push(this);
    };

	static render(data: any, meta?: Gap, parent?: Component){
		if (data instanceof HTMLElement){
			//return this.renderIn.apply(this, arguments);
		};
		const ctor = this as any as ComponentClass;
		if (this.rootGap === null){
			throw new Error(`Cannot render [${this.name}] - no template`);
		};
		const inst = new ctor(parent, meta); 
		const rootMeta: IRenderMeta = {
			dynamicPath: []
		};
		inst.tplData = this.transformData(data, TransformUtils);
		inst.objectStorage.hash(inst.tplData);
		inst.code = this.rootGap.render(inst, inst.tplData, rootMeta);
		return inst;
	};

	update (newData: any){
		const transformedData: any = this.Class.transformData(newData, TransformUtils);
		const hash = this.objectStorage.hash(transformedData);
		if (hash === this.currentHash){
			return;
		};		
		const meta: IRenderMeta = {
			dynamicPath: []
		};
		this.Class.rootGap.update(this, meta, this.tplData, transformedData);
	};

	on(event: string, fn: Function){
		globalEvents.listen(event);
		this.eventEmitter.on(event, fn);	
	};

	emit(...rest: any[]){
		this.eventEmitter.emit.apply(this.eventEmitter, arguments);		
	};

	emitApply(...rest: any[]){
		this.eventEmitter.emit.apply(this.eventEmitter, arguments);		
	};

	toString(){
		return this.code;
	};

	getHtml(data: any): string{
		this.data = data;  		      
		const cookedData = this.Class.cookData(data);
        return this.Class.rootGap.render(this, data, null);
	};

	updatePath(scopePath: string[], newValue: any){
		

	};


	remove(virtual: boolean){
		
	};

	rerender(data: any){
		
	};

	getDom(){
		//return this.rootGap.getDom();
	};

};

export function getDefaultClass(): typeof Component{
	class ComponentDefault extends Component {};
	return ComponentDefault;
};

function match(fg: Component, node: HTMLElement, selector: string){
	let domElms = fg.getDom();
	while (node){
		if (node.matches(selector)){
			return true;
		};
		// if (domElms.indexOf(node) >= 0){
		// 	return false;
		// };		
		node = node.parentElement;
	};
	return false;
};

export function getFgByIid(iid: number): Component{
	return fgInstanceTable[iid];
};