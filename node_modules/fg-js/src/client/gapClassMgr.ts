"use strict";

import {Component} from './componentBase';
import {IDataPath, IDataQueryObj, DataQuery} from '../valueMgr';
import * as utils from '../utils';
import * as valueMgr from '../valueMgr';
import {IAstNode} from '../outerTypes';
import DataDispatcher from '../dataDispatcher';

export interface IGapData{
	type: string;
	dataSource: IDataQueryObj;
	eid?: string;
	scope?: valueMgr.IScopeData;
};

export interface IScopeTable {
	[key: string]: IDataPath;
};

export type GapClass = new (parsedMeta: IGapData, parent: Gap) => Gap;

export abstract class Gap{
	type: string;
	children: Gap[] = [];
	dataSource: DataQuery;
	parent: Gap;
	root: Gap;
	context: Component;
	eid: string;
	gid: number;
	isVirtual: boolean;

	dataSourceInit(parsed: IGapData){
		if (!parsed.dataSource){
			return;
		};
		this.dataSource = new DataQuery(parsed.dataSource);
	};

	public static priority: number = 0;

	constructor (parsedMeta: IGapData, parent: Gap){	
		utils.extend(this, parsedMeta); // todo: why?
		this.children = [];	
		this.context = null;			
		if (parent){
			this.parent = parent;					
			this.root = parent.root;
			parent.children.push(this);
		}else{
			this.parent = null;					
			this.root = this;
		};
		this.dataSourceInit(parsedMeta);			
	};

	static parse(node: IAstNode, dataDispatcher: DataDispatcher, parents: IGapData[], html?: string): IGapData{
		return null;
	};

	abstract render(context: Component, data: any, meta: valueMgr.IRenderMeta): string;

	update(context: Component, meta: Gap, scopePath: any, value: any, oldValue: any): void{
		return;
	};

	getParents(): Gap[] {
		let arr: Gap[] = [];
		let parent = this.parent;
		while (parent){
			arr.push(parent);
			parent = parent.parent;
		};
		return arr;
	}
};

import gaps from '../gaps';