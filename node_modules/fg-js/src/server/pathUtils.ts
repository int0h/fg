import * as vanilaPath from 'path'; 
const path = require('upath');

export class FsPath {

    relative: boolean;
    root: string | null;
    parts: string[];
  
    constructor (parts: string[], root: string){
        this.relative = root === null;
        this.root = root;
        this.parts = parts;
    };

    static parse(str: string | FsPath): FsPath {
        if (str instanceof FsPath){
            return str as FsPath;
        };
        const parsed = path.parse(str) as vanilaPath.ParsedPath;
        const unrootedDir = parsed.dir.slice(parsed.root.length);
        const dirParts = unrootedDir === ""
            ? []
            : unrootedDir.split('/');
        const parts = [...dirParts, parsed.base];
        const root = parsed.root || null;  
        return new FsPath(parts, root);
    };

    get filename(): string {
        return this.parts[this.parts.length - 1];
    };

    get ext(): string {
        const found = /\.[^\.]*$/.exec(this.filename);
        return found && found[0];
    };

    static normalize(parts: string[], isRelative: boolean = false): string[] {
        let newParts: string[] = [];
        let backPath: string[] = [];
        parts.forEach(part => {
            if (part === '.'){
                return;
            };
            if (part === '..'){
                if (newParts.length > 0){
                    newParts.pop();
                    return;
                };
                if (isRelative){
                    backPath.push('..');
                    return;            
                };
                throw new Error('Relative parts refers to far backwards');
            };
            newParts.push(part);        
        });
        return [...backPath, ...newParts];
    };

    toString(): string {
        const root = this.relative
            ? ''
            : this.root;
        return root + this.parts.join('/');
    }

    static join(...relPaths: (string | FsPath)[]): FsPath {
        const relParsed: FsPath[] = relPaths.map(relPath => FsPath.parse(relPath));
        let newParts: string[] = [];         
        relParsed.forEach(relPath => {
            newParts = newParts.concat(relPath.parts);
        });
        newParts = FsPath.normalize(newParts, relParsed[0].relative);        
        let inst = new FsPath(newParts, relParsed[0].root);
        return inst;
    };
};

export default function (...args: string[]): string{
    return FsPath.join(...args).toString();
}